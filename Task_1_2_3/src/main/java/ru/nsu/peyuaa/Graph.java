/*
 * This Java source file was generated by the Gradle 'init' task.
 */

package ru.nsu.peyuaa;

import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStream;
import java.io.InputStreamReader;
import java.util.ArrayDeque;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collections;
import java.util.Deque;
import java.util.HashMap;
import java.util.Iterator;
import java.util.LinkedList;
import java.util.List;
import java.util.Map;
import java.util.Map.Entry;
import java.util.Optional;

/**
 * Graph class.
 *
 * @param <T> type of the value.
 */
public class Graph<T> {
    /**
     * Vertex class.
     *
     * @param <T> type of the vertex value.
     */
    public static class Vertex<T> {
        T value;
        List<Edge<T>> edges;

        public Vertex(T value) {
            this.value = value;
        }
    }

    /**
     * Edge class.
     *
     * @param <T> type of the vertex value.
     */
    public static class Edge<T> {
        int weight;
        Vertex<T> from;
        Vertex<T> to;

        /**
         * Edge constructor.
         *
         * @param weight of the edge.
         * @param from which vertex edge come out.
         * @param to which vertex edge come in.
         */
        public Edge(int weight, Vertex<T> from, Vertex<T> to) {
            this.weight = weight;
            this.from = from;
            this.to = to;
        }
    }

    private final Map<Vertex<T>, Map<Vertex<T>, Integer>> adjacencyMatrix = new HashMap<>();
    private final Map<Vertex<T>, Map<Edge<T>, Integer>> incidenceMatrix = new HashMap<>();
    private final Map<Vertex<T>, Map<Vertex<T>, Integer>> adjacencyList = new HashMap<>();

    private final List<Vertex<T>> vertices = new LinkedList<>();
    private final List<Edge<T>> edges = new LinkedList<>();

    /**
     * Graph constructor. Initialize all graph's fields.
     */
    public Graph() {
    }

    private void addVertexToVertices(Vertex<T> vertex) {
        vertices.add(vertex);
    }

    private void addVertexToAdjacencyMatrix(Vertex<T> vertex) {
        adjacencyMatrix.put(vertex, new HashMap<>());
    }

    private void addVertexToIncidenceMatrix(Vertex<T> vertex) {
        incidenceMatrix.put(vertex, new HashMap<>());
    }

    private void addVertexToAdjacencyList(Vertex<T> vertex) {
        adjacencyList.put(vertex, new HashMap<>());
    }

    /**
     * Add vertex with the value.
     *
     * @param value of the vertex.
     */
    public void addVertex(T value) {
        Vertex<T> vertex = new Vertex<>(value);
        vertex.edges = new LinkedList<>();
        addVertexToVertices(vertex);
        addVertexToAdjacencyMatrix(vertex);
        addVertexToIncidenceMatrix(vertex);
        addVertexToAdjacencyList(vertex);
    }

    /**
     * Add vertices with values.
     *
     * @param values of the vertices.
     */
    public void addVertices(T[] values) {
        for (T value : values) {
            addVertex(value);
        }
    }

    /**
     * Return vertex with the value.
     *
     * @param value of the vertex.
     * @return vertex with the value.
     */
    public Optional<Vertex<T>> getVertex(T value) {
        return vertices.stream().filter(vertex -> vertex.value.equals(value)).findAny();
    }

    /**
     * Return incident edges.
     *
     * @param value of the vertex.
     * @return list of the edges incident to vertex with the value.
     */
    public Optional<List<Edge<T>>> getVertexEdges(T value) {
        return getVertex(value).map(vertex -> vertex.edges);
    }

    /**
     * Delete vertex with the value in adjacency matrix.
     *
     * @param value delete vertex with the value.
     */
    private void deleteVertexFromAdjacencyMatrix(T value) {
        getVertex(value).ifPresent(vertex -> {
            adjacencyMatrix.remove(vertex);
            vertices.stream().filter(currentVertex -> !currentVertex.equals(vertex))
                    .map(currentVertex -> adjacencyMatrix.get(currentVertex).remove(vertex));
        });
    }

    /**
     * Delete vertex with the value in vertices list.
     *
     * @param value delete vertex with the value.
     */
    private void deleteVertexFromVerticesList(T value) {
        for (Iterator<Vertex<T>> iterator = vertices.listIterator(); iterator.hasNext();) {
            Vertex<T> vertex = iterator.next();
            if (vertex.value.equals(value)) {
                for (Edge<T> edge : vertex.edges) {
                    deleteEdgeFromEdges(edge);
                }
                iterator.remove();
            }
        }
    }

    /**
     * Delete vertex with the value in incidence matrix.
     *
     * @param value delete vertex with the value.
     */
    private void deleteVertexFromIncidenceMatrix(T value) {
        getVertex(value).ifPresent(vertex -> {
            vertex.edges.stream().forEach(edge -> deleteEdgeFromIncidenceMatrix(edge));
            incidenceMatrix.remove(vertex);
        });
    }

    /**
     * Delete vertex with the value in adjacency list.
     *
     * @param value delete vertex with the value.
     */
    private void deleteVertexFromAdjacencyList(T value) {
        Optional<Vertex<T>> vertex = getVertex(value);
        if (vertex.isPresent()) {
            for (Vertex<T> currentVertex : vertices) {
                if (!currentVertex.equals(vertex.get())) {
                    adjacencyList.get(currentVertex).remove(vertex.get());
                }
            }
            adjacencyList.remove(vertex.get());
        }
    }

    /**
     * Delete vertex with the value.
     *
     * @param value delete vertex with the value.
     */
    public void deleteVertex(T value) {
        deleteVertexFromAdjacencyMatrix(value);
        deleteVertexFromIncidenceMatrix(value);
        deleteVertexFromAdjacencyList(value);
        deleteVertexFromVerticesList(value);
    }

    /**
     * Add edge in the list of edges.
     *
     * @param edge to add.
     */
    private void addEdgeToEdges(Edge<T> edge) {
        edges.add(edge);
        edge.from.edges.add(edge);
        edge.to.edges.add(edge);
    }

    /**
     * Add edge in adjacency matrix.
     *
     * @param edge to add.
     */
    private void addEdgeInAdjacencyMatrix(Edge<T> edge) {
        adjacencyMatrix.get(edge.to).put(edge.from, edge.weight);
    }

    /**
     * Add edge in incidence matrix.
     *
     * @param edge to add.
     */
    private void addEdgeInIncidenceMatrix(Edge<T> edge) {
        incidenceMatrix.get(edge.from).put(edge, -edge.weight);
        incidenceMatrix.get(edge.to).put(edge, edge.weight);
    }

    /**
     * Add edge in adjacency list.
     *
     * @param edge to add.
     */
    private void addEdgeInAdjacencyList(Edge<T> edge) {
        adjacencyList.get(edge.from).put(edge.to, edge.weight);
    }

    /**
     * Add new edge.
     *
     * @param weight of edge.
     * @param from which vertex
     * @param to which vertex
     */
    public void addEdge(int weight, Vertex<T> from, Vertex<T> to) {
        Edge<T> edge = new Edge<>(weight, from, to);
        addEdgeToEdges(edge);
        addEdgeInAdjacencyMatrix(edge);
        addEdgeInIncidenceMatrix(edge);
        addEdgeInAdjacencyList(edge);
    }

    /**
     * Delete edge from edges list.
     *
     * @param edge we want to delete.
     */
    private void deleteEdgeFromEdges(Edge<T> edge) {
        edge.from.edges.remove(edge);
        edge.to.edges.remove(edge);
        edges.remove(edge);
    }

    /**
     * Delete edge from adjacency matrix.
     *
     * @param edge we want to delete.
     */
    private void deleteEdgeFromAdjacencyMatrix(Edge<T> edge) {
        adjacencyMatrix.get(edge.to).put(edge.from, 0);
    }

    /**
     * Delete edge from incidence matrix.
     *
     * @param edge we want to delete.
     */
    private void deleteEdgeFromIncidenceMatrix(Edge<T> edge) {
        for (Vertex<T> vertex : vertices) {
            incidenceMatrix.get(vertex).remove(edge);
        }
    }

    /**
     * Delete edge from adjacency list.
     *
     * @param edge we want to delete.
     */
    private void deleteEdgeFromAdjacencyList(Edge<T> edge) {
        adjacencyList.get(edge.from).remove(edge.to);
    }

    /**
     * Delete edge.
     *
     * @param edge we want to delete.
     */
    public void deleteEdge(Edge<T> edge) {
        deleteEdgeFromAdjacencyMatrix(edge);
        deleteEdgeFromIncidenceMatrix(edge);
        deleteEdgeFromAdjacencyList(edge);
        deleteEdgeFromEdges(edge);
    }

    /**
     * Return vertex value.
     *
     * @param vertex which value we want to get.
     * @return vertex value.
     */
    public T getValue(Vertex<T> vertex) {
        return vertex.value;
    }

    /**
     * Change vertex value.
     *
     * @param vertex which value we want to change.
     * @param value is new vertex value.
     */
    public void changeValue(Vertex<T> vertex, T value) {
        vertex.value = value;
    }

    /**
     * Change edge weight.
     *
     * @param edge which weight we want to change.
     * @param weight is a new weight value.
     */
    private void changeWeightInEdges(Edge<T> edge, int weight) {
        edge.weight = weight;
    }

    /**
     * Change edge weight in adjacency matrix.
     *
     * @param edge which weight we want to change.
     * @param weight is a new weight value.
     */
    private void changeWeightInAdjacencyMatrix(Edge<T> edge, int weight) {
        adjacencyMatrix.get(edge.to).put(edge.from, weight);
    }

    /**
     * Change edge weight in incidence matrix.
     *
     * @param edge which weight we want to change.
     * @param weight is a new weight value.
     */
    private void changeWeightInIncidenceMatrix(Edge<T> edge, int weight) {
        incidenceMatrix.get(edge.from).put(edge, -weight);
        incidenceMatrix.get(edge.to).put(edge, weight);
    }

    /**
     * Change edge weight in adjacency list.
     *
     * @param edge which weight we want to change.
     * @param weight is a new weight value.
     */
    private void changeWeightInAdjacencyList(Edge<T> edge, int weight) {
        adjacencyList.get(edge.from).put(edge.to, weight);
    }

    /**
     * Change edge weight.
     *
     * @param edge which weight we want to change.
     * @param weight is a new weight value.
     */
    public void changeWeight(Edge<T> edge, int weight) {
        changeWeightInEdges(edge, weight);
        changeWeightInAdjacencyMatrix(edge, weight);
        changeWeightInIncidenceMatrix(edge, weight);
        changeWeightInAdjacencyList(edge, weight);
    }

    /**
     * Return edge weight.
     *
     * @param edge which weight we want to get.
     * @return edge weight.
     */
    public int getWeight(Edge<T> edge) {
        return edge.weight;
    }

    /**
     * Print adjacency matrix.
     */
    public void printAdjacencyMatrix() {
        System.out.println("Adjacency matrix:");
        for (Vertex<T> vertex : vertices) {
            System.out.print(vertex.value + " ");
        }
        System.out.println();
        for (int i = 0; i < vertices.size(); i++) {
            for (Vertex<T> vertex : vertices) {
                int weight = adjacencyMatrix.get(vertices.get(i)).get(vertex) != null
                        ? adjacencyMatrix.get(vertices.get(i)).get(vertex) : 0;
                System.out.print(weight + " ");
            }
            System.out.println();
        }
    }

    /**
     * Print incidence matrix.
     */
    public void printIncidenceMatrix() {
        System.out.println("Incidence matrix:");
        for (Vertex<T> vertex : vertices) {
            System.out.print(vertex.value + " ");
        }
        System.out.println();

        for (Vertex<T> vertex : vertices) {
            for (Edge<T> edge : edges) {
                int weight = incidenceMatrix.get(vertex).get(edge) != null
                        ? incidenceMatrix.get(vertex).get(edge) : 0;
                System.out.print(weight + " ");
            }
            System.out.println();
        }
    }

    /**
     * Prints adjacency list.
     */
    public void printAdjacencyList() {
        System.out.println("Adjacency list:");
        for (Vertex<T> vertex : vertices) {
            System.out.print(vertex.value + " ");
        }
        System.out.println();

        for (int i = 0; i < vertices.size(); i++) {
            if (adjacencyList.containsKey(vertices.get(i))) {
                System.out.print(vertices.get(i).value + " ");
                for (Vertex<T> vertex : vertices) {
                    if (adjacencyList.get(vertices.get(i)).containsKey(vertex)) {
                        System.out.print(vertex.value + " "
                                + adjacencyList.get(vertices.get(i)).get(vertex) + " ");
                    }
                }
                System.out.println();
            }

        }
    }

    /**
     * Loads graph's initial state from adjacency matrix.
     * First line of the file - values of nodes.
     * The order of the vertices in the matrix corresponds
     * to the order of the vertex values in the first line of the file.
     * A_ij = N if there is an edge from j to i with weight N.
     * A_ij = 0 otherwise.
     *
     * @param inputStream with initial data.
     * @throws IOException if there is any problems with file reading.
     */
    public void loadAdjacencyMatrix(InputStream inputStream) throws IOException {
        try (var reader = new BufferedReader(new InputStreamReader(inputStream))) {
            String currentLine = reader.readLine();

            String[] verticesValues = currentLine.split(" ");
            addVertices((T[]) verticesValues);

            for (String verticesValue : verticesValues) {
                currentLine = reader.readLine();
                int[] weights = Arrays.stream(currentLine.split(" "))
                        .mapToInt(Integer::parseInt).toArray();

                Optional<Vertex<T>> toVertex = getVertex((T) verticesValue);

                for (int j = 0; j < weights.length; j++) {
                    if (weights[j] != 0) {
                        Optional<Vertex<T>> fromVertex = getVertex((T) verticesValues[j]);

                        if (toVertex.isPresent() && fromVertex.isPresent()) {
                            addEdge(weights[j], fromVertex.get(), toVertex.get());
                        }
                    }
                }
            }
        }
    }

    /**
     * Loads graph's initial state from incidence matrix.
     * First line of the file - values of vertices.
     * The order of the vertices in the matrix corresponds
     * to the order of the vertex values in the first line of the file.
     * A_ij more than 0 if there is an edge into vertex i.
     * A_ij less than 0 if there is and edge from vertex i.
     * A_ij = 0 otherwise.
     *
     * @param inputStream with initial data.
     * @throws IOException if there is any problems with file reading.
     */
    public void loadIncidenceMatrix(InputStream inputStream) throws IOException {
        try (var reader = new BufferedReader(new InputStreamReader(inputStream))) {
            String currentLine = reader.readLine();

            String[] verticesValues = currentLine.split(" ");
            addVertices((T[]) verticesValues);

            int[][] weights = new int[verticesValues.length][];

            for (int i = 0; i < verticesValues.length; i++) {
                currentLine = reader.readLine();
                weights[i] = Arrays.stream(currentLine.split(" "))
                        .mapToInt(Integer::parseInt).toArray();
            }

            for (int i = 0; i < weights[0].length; i++) {
                int fromVertexIndex = -1;
                int toVertexIndex = -1;

                for (int j = 0; j < weights.length; j++) {
                    if (weights[j][i] > 0) {
                        toVertexIndex = j;
                    } else if (weights[j][i] < 0) {
                        fromVertexIndex = j;
                    }
                }
                Optional<Vertex<T>> fromVertex = getVertex((T) verticesValues[fromVertexIndex]);
                Optional<Vertex<T>> toVertex = getVertex((T) verticesValues[toVertexIndex]);

                if (fromVertex.isPresent() && toVertex.isPresent()) {
                    addEdge(weights[toVertexIndex][i], fromVertex.get(),
                            toVertex.get());
                }
            }
        }
    }

    /**
     * Loads graph's initial state from adjacency list.
     * First line of the file - values of nodes.
     * Other lines - first value in the line is a node from which edges go to another vertex.
     * After first values there is a pairs
     * [node_value] [weight of edge from first vertex in the line to the vertex with [node_value]]
     *
     * @param inputStream with initial data.
     * @throws IOException if there is any problems with file reading.
     */
    public void loadAdjacencyList(InputStream inputStream) throws IOException {
        try (var reader = new BufferedReader(new InputStreamReader(inputStream))) {
            String currentLine = reader.readLine();

            String[] verticesValues = currentLine.split(" ");
            addVertices((T[]) verticesValues);

            while ((currentLine = reader.readLine()) != null) {
                verticesValues = currentLine.split(" ");
                for (int i = 1; i < verticesValues.length; i = i + 2) {
                    Optional<Vertex<T>> fromVertex = getVertex((T) verticesValues[0]);
                    Optional<Vertex<T>> toVertex = getVertex((T) verticesValues[i]);
                    if (fromVertex.isPresent() && toVertex.isPresent()) {
                        addEdge(Integer.parseInt(verticesValues[i + 1]),
                                fromVertex.get(), toVertex.get());
                    }
                }
            }
        }
    }

    private void topologicalSortUtil(int v, boolean[] visited, Deque<Integer> deque) {
        visited[v] = true;

        for (Entry<Vertex<T>, Integer> entry : adjacencyList.get(vertices.get(v)).entrySet()) {
            int index = vertices.indexOf(entry.getKey());
            if (!visited[index]) {
                topologicalSortUtil(index, visited, deque);
            }
        }

        deque.addLast(v);
    }

    private List<Integer> topologicalSort(int v) {
        Deque<Integer> deque = new ArrayDeque<>();

        boolean[] visited = new boolean[vertices.size()];

        for (int i = 0; i < vertices.size(); i++) {
            visited[i] = false;
        }

        topologicalSortUtil(v, visited, deque);

        for (int i = 0; i < vertices.size(); i++) {
            if (!visited[i]) {
                topologicalSortUtil(i, visited, deque);
            }
        }

        List<Integer> sortedVertices = new ArrayList<>(deque);
        Collections.reverse(sortedVertices);

        return sortedVertices;
    }

    /**
     * Sorts vertices by distance.
     *
     * @param value of the start vertex.
     */
    public void sortVertices(T value) {
        Optional<Vertex<T>> initialVertex = getVertex(value);
        if (initialVertex.isPresent()) {
            int index = vertices.indexOf(initialVertex.get());
            List<Integer> topologicallySortedVertices = topologicalSort(index);

            int[] distance = new int[vertices.size()];
            for (int i = 0; i < vertices.size(); i++) {
                distance[i] = -1;
            }
            distance[index] = 0;

            for (Integer topologicallySortedVertex : topologicallySortedVertices) {
                for (Entry<Vertex<T>, Integer> entry :
                        adjacencyList.get(vertices.get(topologicallySortedVertex)).entrySet()) {
                    int vertexTo = vertices.indexOf(entry.getKey());
                    if ((distance[vertexTo] == -1)
                            || (distance[vertexTo]
                            > distance[topologicallySortedVertex] + entry.getValue())) {
                        distance[vertexTo] = distance[topologicallySortedVertex] + entry.getValue();
                    }
                }
            }

            Map<T, Integer> unsortedVertices = new HashMap<>();
            for (int i = 0; i < vertices.size(); i++) {
                unsortedVertices.put(vertices.get(i).value, distance[i]);
            }

            unsortedVertices.entrySet().stream()
                    .sorted(Entry.comparingByValue())
                    .forEach(k -> System.out.println(k.getKey() + ": " + k.getValue()));

        }
    }
}
